/**
* Name: TenMarch
* Based on the internal empty template. 
* Author: valencia
* Tags: 
*/


model TenMarch

/* Insert your model definition here */

/*
> Jay and Val GAMA Experimentation (Until WED MORNING) -- 1 FLOOR
> > Import and make shape file
> > See this file is interactable and able to visualise the bin, tenant locations
> > Algorithm to move on a route
 
 */
 
 
global {
	
	file shape_file_buildings <- shape_file('../includes/building.shp', 0);
	file shape_file_roads <- shape_file('../includes/road.shp', 0);
	file shape_file_bounds <- shape_file('../includes/bounds.shp', 0);
	graph the_graph;
//	
//	//number of obstacles
//	int nb_obstacles <- 20 parameter: true;
	
	//perception distance
	float perception_distance <- 40.0 parameter: true;
	
	//precision used for the masked_by operator (default value: 120): the higher the most accurate the perception will be, but it will require more computation
	int precision <- 600 parameter: true;
	
	//space where the agent can move.
	geometry free_space <- envelope(shape_file_buildings);
	init {
		
		create obstacle from: shape_file_buildings with: [type:: string(read('NATURE'))] {
//			shape <- rectangle(2+rnd(20), 2+rnd(20));
//			free_space <- free_space - shape;
		}
		
		create road from: shape_file_roads;
		the_graph <- as_edge_graph(road);
		ask road {
			do build_intersection_areas pedestrian_graph: the_graph;
		}
		
		create people  {
			location <- any_location_in(free_space);
		}
		create bin {
			location <- any_location_in(free_space);
		}
	}
}


species road skills: [pedestrian_road]{
	rgb color <- #black;

	aspect base {
		draw shape color: color;
		if (free_space != nil){
			draw free_space color: #lightpink border: #black;
		} 
	}
}


species obstacle {
	string type;
	aspect default {
		draw shape color: #gray border: #black;
	}
}
species people skills: [moving]{
	bool has_trash <- true; 
	//list<point> path;
	
	//zone of perception
	geometry perceived_area;
	
	//the target it wants to reach
	bin target ;
	
    reflex search_target when: target = nil{
    	ask bin {
    		myself.target <- self;
    	}
    		if (perceived_area = nil) or (perceived_area.area < 2.0) {
				//if the agent has no target or if the perceived area is empty (or too small), 
				//it moves randomly inside the free_space
				do wander bounds: free_space;
			} 
    }
    
    // Compute a new path only if no valid path exists
//    reflex compute_path when: target != nil and (path = nil or path.length = 0) {
//        path <- path_to(location, target.location);
//    }

  // Follow the computed path step by step
//    reflex follow_path when: path != nil and path.length > 0 {
//        speed <- 0.8;
//        do move_to (path.first);  // Move to the next point in the path
//        path <- path - path.first;  // Remove the visited point
//
//        // If reached target, drop the trash and stop moving
//        if (location = target.location) {
//            has_trash <- false;
//            path <- nil;
//        }
//    }
//    
    reflex follow when: target!=nil {
		speed <- 0.8;
		do goto target: target;
		has_trash <- false;
    }
//    
    reflex stay when: has_trash = false{}
    

	
	
	//computation of the perceived area
	reflex update_perception {
		//the agent perceived a cone (with an amplitude of 60Â°) at a distance of  perception_distance (the intersection with the world shape is just to limit the perception to the world)
		perceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(perception_distance); 
		
		//if the perceived area is not nil, we use the masked_by operator to compute the visible area from the perceived area according to the obstacles
		if (perceived_area != nil) {
			perceived_area <- perceived_area masked_by (obstacle,precision);

		}
	}
	
	aspect body {
		draw triangle(2) rotate:90 + heading color: #red;
		if (target!=nil) {
	    draw polyline([self.location,target.location]) color:#black;
	}
	}
	aspect perception {
		if (perceived_area != nil) {
			draw perceived_area color: #green;
			draw circle(1) at: target.location color: #magenta;
			
		}
	}
}

species bin {
    //point position <- {50, 50, 0}; // Staircase in middle of building
    
    aspect base {
        draw square(3) color: #blue depth:3 ;
        
    }
}

experiment fieldofvision type: gui {
	float minimum_cycle_duration <- 0.05;
	output synchronized: true {
		display view{
			species obstacle;
			species people aspect: perception transparency: 0.5;
			species people aspect: body;
			species bin aspect: base;
		}
	}
}
 