/**
* Name: PedestrianToBin
* Based on pedestrian_complex_environment and TenMarch models
* Author: Claude
* Tags: pedestrian, obstacle avoidance, pathfinding
*/

model PedestrianToBin

global {
    // Parameters for pedestrian movement
    bool display_force <- false parameter: true;
    bool display_target <- true parameter: true;
    bool display_circle_min_dist <- true parameter: true;
    
    float P_shoulder_length <- 0.45 parameter: true;
    float P_proba_detour <- 0.5 parameter: true;
    bool P_avoid_other <- true parameter: true;
    float P_obstacle_consideration_distance <- 3.0 parameter: true;
    float P_pedestrian_consideration_distance <- 3.0 parameter: true;
    float P_tolerance_target <- 0.1 parameter: true;
    bool P_use_geometry_target <- true parameter: true;
    
    // Social Force Model parameters
    string P_model_type <- "simple" among: ["simple", "advanced"] parameter: true;
    
    // SFM advanced parameters
    float P_A_pedestrian_SFM_advanced parameter: true <- 0.16 category: "SFM advanced";
    float P_A_obstacles_SFM_advanced parameter: true <- 1.9 category: "SFM advanced";
    float P_B_pedestrian_SFM_advanced parameter: true <- 0.1 category: "SFM advanced";
    float P_B_obstacles_SFM_advanced parameter: true <- 1.0 category: "SFM advanced";
    float P_relaxion_SFM_advanced parameter: true <- 0.5 category: "SFM advanced";
    float P_gama_SFM_advanced parameter: true <- 0.35 category: "SFM advanced";
    float P_lambda_SFM_advanced <- 0.1 parameter: true category: "SFM advanced";
    float P_minimal_distance_advanced <- 0.25 parameter: true category: "SFM advanced";
    
    // SFM simple parameters
    float P_n_prime_SFM_simple parameter: true <- 3.0 category: "SFM simple";
    float P_n_SFM_simple parameter: true <- 2.0 category: "SFM simple";
    float P_lambda_SFM_simple <- 2.0 parameter: true category: "SFM simple";
    float P_gama_SFM_simple parameter: true <- 0.35 category: "SFM simple";
    float P_relaxion_SFM_simple parameter: true <- 0.54 category: "SFM simple";
    float P_A_pedestrian_SFM_simple parameter: true <- 4.5 category: "SFM simple";
    
    float step <- 0.1;
    
    // Number of obstacles
    int nb_obstacles <- 10 parameter: true;
    
    // Space where agents can move
    geometry free_space <- copy(shape);
    
    // Graph for navigation
    graph pedestrian_network;
    
    init {
        // Create obstacles
        create obstacle number: nb_obstacles {
            shape <- rectangle(2 + rnd(20), 2 + rnd(20));
            free_space <- free_space - shape;
        }
        
        // Create pedestrian paths
        list<geometry> path_geoms <- [];
        
        // Create a set of lines connecting random points in free space for navigation
        int nb_points <- 50;
        list<point> path_points <- nb_points among(free_space.points);
        
        // Create a spanning tree of lines to ensure connectivity
        loop i from: 0 to: length(path_points) - 2 {
            geometry line <- line([path_points[i], path_points[i+1]]);
            add line to: path_geoms;
        }
        
        // Add some additional random connections
        loop times: 20 {
            point p1 <- one_of(path_points);
            point p2 <- one_of(path_points - p1);
            if (p1 != nil and p2 != nil) {
                geometry line <- line([p1, p2]);
                add line to: path_geoms;
            }
        }
        
        // Create paths from the geometries
        create pedestrian_path from: path_geoms;
        
        // Build the navigation graph
        pedestrian_network <- as_edge_graph(pedestrian_path);
        
        // Create a bin at a random location
        create bin {
            location <- any_location_in(free_space);
        }
        
        // Create a person at a random location
        create people {
            location <- any_location_in(free_space);
            has_trash <- true;
            
            // Set pedestrian parameters
            obstacle_consideration_distance <- P_obstacle_consideration_distance;
            pedestrian_consideration_distance <- P_pedestrian_consideration_distance;
            shoulder_length <- P_shoulder_length;
            avoid_other <- P_avoid_other;
            proba_detour <- P_proba_detour;
            
            use_geometry_waypoint <- P_use_geometry_target;
            tolerance_waypoint <- P_tolerance_target;
            pedestrian_species <- [people];
            obstacle_species <- [obstacle];
            
            pedestrian_model <- P_model_type;
            
            // Set SFM model parameters based on selected model type
            if (pedestrian_model = "simple") {
                A_pedestrians_SFM <- P_A_pedestrian_SFM_simple;
                relaxion_SFM <- P_relaxion_SFM_simple;
                gama_SFM <- P_gama_SFM_simple;
                lambda_SFM <- P_lambda_SFM_simple;
                n_prime_SFM <- P_n_prime_SFM_simple;
                n_SFM <- P_n_SFM_simple;
            } else {
                A_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;
                A_obstacles_SFM <- P_A_obstacles_SFM_advanced;
                B_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;
                B_obstacles_SFM <- P_B_obstacles_SFM_advanced;
                relaxion_SFM <- P_relaxion_SFM_advanced;
                gama_SFM <- P_gama_SFM_advanced;
                lambda_SFM <- P_lambda_SFM_advanced;
                minimal_distance <- P_minimal_distance_advanced;
            }
        }
    }
    
    // Pause simulation when all people have reached their targets
    reflex check_end when: empty(people where each.has_trash) {
        write "All people have disposed of their trash!";
        do pause;
    }
}

// Species for pedestrian paths
species pedestrian_path skills: [pedestrian_road] {
    aspect default {
        draw shape color: #gray;
    }
}

// Species for obstacles
species obstacle {
    aspect default {
        draw shape color: #gray border: #black;
    }
}

// Species for trash bins
species bin {
    aspect default {
        draw square(3) color: #blue depth: 3;
    }
}

// Species for people with pedestrian skill
species people skills: [pedestrian] {
    bool has_trash <- true;
    rgb color <- #red;
    float speed <- 5.0 #km/#h;
    bin target;
    bool path_computed <- false;
    
    // Find target bin if none is set
    reflex search_target when: has_trash and target = nil {
        ask bin closest_to self {
            myself.target <- self;
        }
    }
    
    // Move towards bin using pedestrian navigation
    reflex move_to_bin when: has_trash and target != nil {
        if (!path_computed) {
            if (pedestrian_network != nil and !empty(pedestrian_network.edges)) {
                do compute_virtual_path pedestrian_graph: pedestrian_network target: target.location; 
                path_computed <- true;
            } else {
                // If no path available, move directly towards target
                do goto target: target.location;
            }
        } else {
            // Make sure we have a valid path before walking
            if (current_path != nil and !empty(current_path.edges)) {
                do walk;
            } else {
                // If no valid path, try direct movement
                do goto target: target.location;
            }
        }
        
        // Check if reached the bin
        if location distance_to target.location < 1.0 {
            has_trash <- false;
            write "Person " + name + " has reached the bin!";
        }
    }
    
    aspect default {
        if display_circle_min_dist and minimal_distance > 0 {
            draw circle(minimal_distance).contour color: color;
        }
        
        draw triangle(2) color: has_trash ? #red : #green rotate: heading + 90.0;
        
        // Only draw the line to current waypoint if it exists
        if display_target and current_waypoint != nil and current_waypoint != location {
            draw line([location, current_waypoint]) color: color;
        }
        
        // Draw a line to the target if no waypoint
        if display_target and current_waypoint = nil and target != nil {
            draw line([location, target.location]) color: #orange;
        }
        
        if display_force and !empty(forces) {
            loop op over: forces.keys {
                if forces[op] != nil {
                    if (species(agent(op)) = obstacle) {
                        draw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;
                    } else if ((agent(op)) = self) {
                        draw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;
                    } else {
                        draw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;
                    }
                }
            }
        }
    }
}

experiment pedestrian_navigation type: gui {
    float minimum_cycle_duration <- 0.05;
    output {
        display view {
            species obstacle;
            species pedestrian_path transparency: 0.5;
            species bin aspect: default;
            species people aspect: default;
        }
    }
}