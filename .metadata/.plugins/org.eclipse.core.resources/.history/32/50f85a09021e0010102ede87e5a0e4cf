

model FirstFloor



global {

	font agent_font <- font("Helvetica", 16, #bold );
	

	int floor_loc_multiplier <- 125;
	
    // set each step to be 1 minute
    float step <- 1 #minutes;
    
    //set the date
	date starting_date <- date([2025,1,1,0,0,0]); // 1 Jan 2025, at 00:00:00
    
    
    // set display text size
    int displayTextSize <- 5;
    
    float ReadyToClear_multiplier <- 0.6;
	float AboutToBeFull_multiplier <- 0.9;
	
	int total_complaints <- 0;
	int weekly_complain_log;
	
	reflex clear_complain_log when: every(7#days){
		weekly_complain_log <- 0;
		write"Cleared log, weekly complain log is now:" + weekly_complain_log;
	}

	
	float total_time_bin_overflowed <- 0.0;
	float weekly_duration_overflow_log;
	
	reflex clear_overflow_log when: every(7#days){
		weekly_duration_overflow_log <- 0;
		write"Cleared log, weekly overflow log is now:" + weekly_duration_overflow_log;
	}
	
	int daily_cleaner_trigger_count;
 	reflex clear_cleaner_trigger_count when: every(1#day){
		daily_cleaner_trigger_count <- 0;
		write"Cleared log, daily cleaner trigger log is now:" + daily_cleaner_trigger_count;
	}
	
	//Set environment size
	geometry shape <- envelope(first(free_spaces_1_shape_file.contents));
	
	
////////////////////////////////////////// LEVEL 1 //////////////////////////////////////////
	file entrance_file <- file("../includes/vidacity_shapes/floor_1/entrypoints.shp");
	// visualisation of layout for lvl 1
	shape_file free_spaces_1_shape_file <- shape_file("../includes/vidacity_shapes/floor_1/outerwall.shp");
	
	// store blocks
	file store_floor_1_file <- file("../includes/vidacity_shapes/floor_1/blockdict.shp");
	
	// routes for lvl 1
	shape_file pedestrian_paths_floor_1_shape_file <- shape_file("../includes/vidacity_shapes/floor_1/path_segments.shp");

	// store boundaries for lvl 1
	file wall_floor_1_shapefile <- file("../includes/vidacity_shapes/floor_1/floor_1_tenant_lines.shp");
	
	//bin locations for lvl 1
	file bin_location_floor_1 <- file("../includes/vidacity_shapes/floor_1/bins.shp");
	
	// tenant spawn location for lvl 1
	file agent_spawn_locations_floor_1 <- file("../includes/vidacity_shapes/floor_1/agent.shp");
	
	// floor stairs file
	file stairs_floor_1 <- file("../includes/vidacity_shapes/floor_1/stairs.shp");
	


	// For 9 stores on level 1:
	
	int lvl1_store_0_no_tenants <- 5 parameter:true category:"Level 1";

	int lvl1_store_1_no_tenants <- 12 parameter:true category:"Level 1";

	int lvl1_store_2_no_tenants <- 2 parameter:true category:"Level 1";
	
	int lvl1_store_3_no_tenants <- 2 parameter:true category:"Level 1";

	int lvl1_store_4_no_tenants <- 5 parameter:true category:"Level 1";

	int lvl1_store_5_no_tenants <- 5 parameter:true category:"Level 1";

	int lvl1_store_6_no_tenants <- 8 parameter:true category:"Level 1";

	int lvl1_store_7_no_tenants <- 15 parameter:true category:"Level 1";
	
	int lvl1_store_8_no_tenants <- 5 parameter:true category:"Level 1";
	
	list no_of_tenants_per_store_lvl1 <- [
		lvl1_store_0_no_tenants,
		lvl1_store_1_no_tenants,
		lvl1_store_2_no_tenants,
		lvl1_store_3_no_tenants,
		lvl1_store_4_no_tenants,
		lvl1_store_5_no_tenants,
		lvl1_store_6_no_tenants,
		lvl1_store_7_no_tenants,
		lvl1_store_8_no_tenants
	];
	
	list<point> store_text_location_1 <-[
		{-50,250,0}, //0
		{38,140,0},
		{135,344,0},
		{212,285,0}, //3
		{120,110,0},
		{270,145,0},
		{405,253,0}, //6
		{474,256,0},
		{410,162,0} //8
		
	];
	
////////////////////////////////////////// LEVEL 1 //////////////////////////////////////////
	
////////////////////////////////////////// LEVEL 2 //////////////////////////////////////////
	// visualisation of layout for lvl 1
	shape_file free_spaces_2_shape_file <- shape_file("../includes/vidacity_shapes/floor_2/outerwall.shp");
	
	// store blocks
	file store_floor_2_file <- file("../includes/vidacity_shapes/floor_2/blockdict.shp");
	
	// routes for lvl 1
	shape_file pedestrian_paths_floor_2_shape_file <- shape_file("../includes/vidacity_shapes/floor_2/path_segments.shp");

	// store boundaries for lvl 1
	file wall_floor_2_shapefile <- file("../includes/vidacity_shapes/floor_2/floor_2_tenant_lines.shp");
	
	//bin locations for lvl 1
	file bin_location_floor_2 <- file("../includes/vidacity_shapes/floor_2/bins.shp");
	
	// tenant spawn location for lvl 1
	file agent_spawn_locations_floor_2 <- file("../includes/vidacity_shapes/floor_2/agent.shp");
	
	// floor stairs file
	file stairs_floor_2 <- file("../includes/vidacity_shapes/floor_2/stairs.shp");


	// For 13 stores on level 2:
	
	int lvl2_store_9_no_tenants <- 5 parameter:true category:"Level 2";

	int lvl2_store_10_no_tenants <- 15 parameter:true category:"Level 2"; 
	
	int lvl2_store_11_no_tenants <- 5 parameter:true category:"Level 2";
	
	int lvl2_store_12_no_tenants <- 8 parameter:true category:"Level 2";
	
	int lvl2_store_13_no_tenants <- 5 parameter:true category:"Level 2";

	int lvl2_store_14_no_tenants <- 2 parameter:true category:"Level 2";

	int lvl2_store_15_no_tenants <- 5 parameter:true category:"Level 2";

	int lvl2_store_16_no_tenants <- 5 parameter:true category:"Level 2";
	
	int lvl2_store_17_no_tenants <- 5 parameter:true category:"Level 2";
	
	int lvl2_store_18_no_tenants <- 5 parameter:true category:"Level 2";
	
	int lvl2_store_19_no_tenants <- 10 parameter:true category:"Level 2";
	
	int lvl2_store_20_no_tenants <- 7 parameter:true category:"Level 2";
	
	int lvl2_store_21_no_tenants <- 5 parameter:true category:"Level 2";
	
	
	
	list no_of_tenants_per_store_lvl2 <- [
		lvl2_store_9_no_tenants,
		lvl2_store_10_no_tenants,
		lvl2_store_11_no_tenants,
		lvl2_store_12_no_tenants,
		lvl2_store_13_no_tenants,
		lvl2_store_14_no_tenants,
		lvl2_store_16_no_tenants,
		lvl2_store_15_no_tenants,
		lvl2_store_17_no_tenants,
		lvl2_store_18_no_tenants,
		lvl2_store_19_no_tenants,
		lvl2_store_20_no_tenants,
		lvl2_store_21_no_tenants
		
	];
	
	list<point> store_text_location_2 <-[
		{45,185,floor_loc_multiplier}, //9
		{42,108,floor_loc_multiplier}, 
		{48,243,floor_loc_multiplier},
		{205,290,floor_loc_multiplier}, //12
		{293,340,floor_loc_multiplier},
		{250,340,floor_loc_multiplier},
		{322,300,floor_loc_multiplier}, //15
		{310,138,floor_loc_multiplier},
		{300,85,floor_loc_multiplier},
		{410,236,floor_loc_multiplier},//18
		{412,286,floor_loc_multiplier},
		{470,235,floor_loc_multiplier},
		{465,288,floor_loc_multiplier} //21
		
	];
	
////////////////////////////////////////// LEVEL 2 //////////////////////////////////////////

////////////////////////////////////////// LEVEL 3 //////////////////////////////////////////
	// visualisation of layout for lvl 1
	shape_file free_spaces_3_shape_file <- shape_file("../includes/vidacity_shapes/floor_3/outerwall.shp");
	
	// store blocks
	file store_floor_3_file <- file("../includes/vidacity_shapes/floor_3/blockdict.shp");
	
	// routes for lvl 1
	shape_file pedestrian_paths_floor_3_shape_file <- shape_file("../includes/vidacity_shapes/floor_3/path_segments.shp");

	// store boundaries for lvl 1
	file wall_floor_3_shapefile <- file("../includes/vidacity_shapes/floor_3/floor_3_tenant_lines.shp");
	
	//bin locations for lvl 1
	file bin_location_floor_3 <- file("../includes/vidacity_shapes/floor_3/bins.shp");
	
	// tenant spawn location for lvl 1
	file agent_spawn_locations_floor_3 <- file("../includes/vidacity_shapes/floor_3/agent.shp");
	
	// floor stairs file
	file stairs_floor_3 <- file("../includes/vidacity_shapes/floor_3/stairs.shp");

	// For 7 stores on level 2:
	
	int lvl3_store_22_no_tenants <- 5 parameter:true category:"Level 3";

	int lvl3_store_23_no_tenants <- 5 parameter:true category:"Level 3";
	
	int lvl3_store_24_no_tenants <- 15 parameter:true category:"Level 3";
	
	int lvl3_store_25_no_tenants <- 5 parameter:true category:"Level 3";
	
	int lvl3_store_26_no_tenants <- 5 parameter:true category:"Level 3";

	int lvl3_store_27_no_tenants <- 7 parameter:true category:"Level 3";

	int lvl3_store_28_no_tenants <- 5 parameter:true category:"Level 3";


	

	
	list no_of_tenants_per_store_lvl3 <- [
		lvl3_store_22_no_tenants,
		lvl3_store_23_no_tenants,
		lvl3_store_24_no_tenants,
		lvl3_store_25_no_tenants,
		lvl3_store_26_no_tenants,
		lvl3_store_27_no_tenants,
		lvl3_store_28_no_tenants
	];
	
	list<point> store_text_location_3 <-[
		{43,187,2*floor_loc_multiplier}, //22
		{42,112,2*floor_loc_multiplier},
		{-10,216,2*floor_loc_multiplier},
		{160,285,2*floor_loc_multiplier}, //25
		{310,285,2*floor_loc_multiplier},
		{270,170,2*floor_loc_multiplier},
		{214,99,2*floor_loc_multiplier} //28
		
	];
	
////////////////////////////////////////// LEVEL 3 //////////////////////////////////////////

////////////////////////////////////////// LEVEL 4//////////////////////////////////////////
	// visualisation of layout for lvl 1
	shape_file free_spaces_4_shape_file <- shape_file("../includes/vidacity_shapes/floor_4/outerwall.shp");
	
	// store blocks
	file store_floor_4_file <- file("../includes/vidacity_shapes/floor_4/blockdict.shp");
	
	// routes for lvl 1
	shape_file pedestrian_paths_floor_4_shape_file <- shape_file("../includes/vidacity_shapes/floor_4/path_segments.shp");

	// store boundaries for lvl 1
	file wall_floor_4_shapefile <- file("../includes/vidacity_shapes/floor_4/floor_4_tenant_lines.shp");
	
	//bin locations for lvl 1
	file bin_location_floor_4 <- file("../includes/vidacity_shapes/floor_4/bins.shp");
	
	// tenant spawn location for lvl 1
	file agent_spawn_locations_floor_4 <- file("../includes/vidacity_shapes/floor_4/agent.shp");
	
	// floor stairs file
	file stairs_floor_4 <- file("../includes/vidacity_shapes/floor_4/stairs.shp");

	// For 4 stores on level 2:
	
	int lvl2_store_29_no_tenants <- 15 parameter:true category:"Level 4";

	int lvl2_store_30_no_tenants <- 4 parameter:true category:"Level 4"; 
	
	int lvl2_store_31_no_tenants <- 2 parameter:true category:"Level 4";
	
	int lvl2_store_32_no_tenants <- 1 parameter:true category:"Level 4";
	
	
	list no_of_tenants_per_store_lvl4 <- [
		lvl2_store_29_no_tenants,
		lvl2_store_30_no_tenants,
		lvl2_store_31_no_tenants,
		lvl2_store_32_no_tenants

	];
	
	list<point> store_text_location_4 <-[
		{37,185,3*floor_loc_multiplier}, //29
		{38,105,3*floor_loc_multiplier},
		{30,217,3*floor_loc_multiplier}, //31
		{180,83,3*floor_loc_multiplier} //32
		
	];
	
////////////////////////////////////////// LEVEL 4 //////////////////////////////////////////

 	list total_tenant_list <- 
 		no_of_tenants_per_store_lvl1 +
 		no_of_tenants_per_store_lvl2 +
 		no_of_tenants_per_store_lvl3 +
 		no_of_tenants_per_store_lvl4
 	;
 	
 	list total_store_text_loc_list <-
 		store_text_location_1 +
 		store_text_location_2 +
 		store_text_location_3 +
 		store_text_location_4
 	;
 	
	
    // Graph for navigation
    graph pedestrian_network_1;
    graph pedestrian_network_2;
    graph pedestrian_network_3;
    graph pedestrian_network_4;
    
    list<graph> pedestrian_network_list;
    
    // for agent spawn
    list ped_list_floor_1;
    list ped_list_floor_2;
    list ped_list_floor_3;
    list ped_list_floor_4;
    
   
	
    
    ///////////////////////    NHPP    /////////////////////    NHPP    /////////////////////    NHPP    /////////////////////
    
    int T <-  1440; // 86400; // 1440 ; // set to 24 hours (23 because 0 is coutned), total time for process to run
    list event_times_this_period;
    list current_cumulative_trash;
    list intensity_values_over_time;
    float cumulative_one_day;
    
    ///////////////////////    NHPP    /////////////////////    NHPP    /////////////////////    NHPP    /////////////////////
        
        
            
    reflex event_happening_event when: current_date.hour = 9 and every(15 #minute){
      create visitor number: 1 from: entrance_file{
       entrance <- location;
       straggler <- false;
       
     }
    }
    
    reflex event_happening_straggler when: every(5 #hour){
      create visitor number: 1 from: entrance_file{
       entrance <- location;
       straggler <- true;
       lifespan <- 0;
       //write "Created straggler as: " + self ;
     }
    }
    
    

    
    point entrance <- (entrance_file.contents at 0).location;
    

    init {
    	
    	if step = 1#second{
    		self.T <- 86400;
    	}
    	else if step = 1#minute {
    		self.T <- 1440;
    	}
    	
    	
    	
        // create cleaner agent
        create cleaner{
        	location <- {97,90,0};
			is_cleaning <- false;
			trash_on_hand <- 0.0;
			max_trash_capacity <- 180.0;
			resting_location <- location;
        }
        
		
		//create central rubbish bin agent
		create central_bin{	
			location <- {178,90,0};
		}		
		
		
		
		
    	
    	// create path for tenants
	    create pedestrian_path from: pedestrian_paths_floor_1_shape_file with:(
	    	floor_no:1
	    	
	    ){
	    	add self to: ped_list_floor_1;
	    }
	    
	    pedestrian_network_1 <- as_edge_graph(ped_list_floor_1);
	    
	    
	    create pedestrian_path from: pedestrian_paths_floor_2_shape_file with:(
	    	floor_no:2
	    	
	    ){
	    	location <- location + {0,0,floor_loc_multiplier};
	    	add self to: ped_list_floor_2;
	    }
	    
	    pedestrian_network_2 <- as_edge_graph(ped_list_floor_2);
	    
	    create pedestrian_path from: pedestrian_paths_floor_3_shape_file with:(
	    	floor_no:3
	    	
	    ){
	    	location <- location + {0,0,2*floor_loc_multiplier};
	    	add self to: ped_list_floor_3;
	    }
	    
	    pedestrian_network_3 <- as_edge_graph(ped_list_floor_3);
	    
	    create pedestrian_path from: pedestrian_paths_floor_4_shape_file with:(
	    	floor_no:4
	    ){
	    	
	    	location <- location + {0,0,3*floor_loc_multiplier};
	    	add self to: ped_list_floor_4;
	    }
	    
	    pedestrian_network_4 <- as_edge_graph(ped_list_floor_4);
	   
	    
		
		pedestrian_network_list <- [
			pedestrian_network_1,
			pedestrian_network_2,
			pedestrian_network_3,
			pedestrian_network_4
		];
				
		
 
 ////////////////////////////////////////// LEVEL 1 //////////////////////////////////////////
 

    	    	    	
        // Create obstacles
        create obstacle from: wall_floor_1_shapefile{
        	floor_no <- 1;
        }
        
        // Create stairs
        create stairs from: stairs_floor_1{
        	floor_no <- 1;
        }
     
        
        create vida_lvl_layout_1 from: free_spaces_1_shape_file;

				
		create bin from: bin_location_floor_1{
			floor_no <- 1;
            current_capacity <- 0.0;
            // set at 45L (450 units)
            max_capacity <- 30.0; //originally 45
            // set by slider, else 0.6 & 0.9
            ReadyToClear_capacity <- ReadyToClear_multiplier * max_capacity;
			AboutToBeFull_capacity<- AboutToBeFull_multiplier * max_capacity;
            ask central_bin{
            	myself.distance_to_central_bin <- self.location distance_to myself.location;
            }
		}
		
		
		list store_spawn_list_lvl_1;
		
		loop store_spawn over:agent_spawn_locations_floor_1{
			store_spawn <- store_spawn.location;
			add store_spawn to:store_spawn_list_lvl_1;
		}
		
		loop store_spawn_loc over:store_spawn_list_lvl_1{
			
			create store with: (
				floor_file:store_floor_1_file,
				floor_no:1,
				text_loc_list:total_store_text_loc_list,
				location:store_spawn_loc,
				ped_path_for_floor:ped_list_floor_1		
			);
			
		}
		
		
		
		create store_floor from: store_floor_1_file with:(
			floor_no:1
		);
		
		
////////////////////////////////////////// LEVEL 1 //////////////////////////////////////////
////////////////////////////////////////// LEVEL 2 //////////////////////////////////////////
    	    	    	
        // Create obstacles
        
        create obstacle from: wall_floor_2_shapefile{
        	floor_no <- 2;
        	
        }

        create vida_lvl_layout_2 from: free_spaces_2_shape_file{
        	location <- location + {0,0,floor_loc_multiplier};
        }
        
        // Create stairs
        create stairs from: stairs_floor_2{
        	floor_no <- 2;
        	location <- location + {0,0,floor_loc_multiplier};
        }

				
		create bin from: bin_location_floor_2{
			location <- location + {0,0,floor_loc_multiplier};
			floor_no <- 2;
            current_capacity <- 0.0;
            // set at 45L (450 units)
            max_capacity <- 30.0; //originally 45
            // set by slider, else 0.6 & 0.9
            ReadyToClear_capacity <- ReadyToClear_multiplier * max_capacity;
			AboutToBeFull_capacity<- AboutToBeFull_multiplier * max_capacity;
            ask central_bin{
            	myself.distance_to_central_bin <- self.location distance_to myself.location;
            }
		}
		
		
		create store_floor from: store_floor_2_file{
			floor_no <- 2;
			location <- location + {0,0,floor_loc_multiplier};
		}
		
		list store_spawn_list_lvl_2;
		
		loop store_spawn over:agent_spawn_locations_floor_2{
			store_spawn <- store_spawn.location + {0,0,floor_loc_multiplier};
			add store_spawn to:store_spawn_list_lvl_2;
		}
		
		loop store_spawn_loc over:store_spawn_list_lvl_2{
			
			create store with: (
				floor_file:store_floor_2_file,
				floor_no:2,
				text_loc_list:total_store_text_loc_list,
				location:store_spawn_loc,
				ped_path_for_floor:ped_list_floor_2		
				
			);
			
		}
		

////////////////////////////////////////// LEVEL 2 //////////////////////////////////////////
//////////////////////////////////////////// LEVEL 3 //////////////////////////////////////////
        // Create obstacles
        
        create obstacle from: wall_floor_3_shapefile{
        	floor_no <- 3;
        	
        }

        create vida_lvl_layout_3 from: free_spaces_3_shape_file{
        	location <- location + {0,0,2*floor_loc_multiplier};
        }
        
        // Create stairs
        create stairs from: stairs_floor_3{
        	floor_no <- 3;
        	location <- location + {0,0,2*floor_loc_multiplier};
        }

				
		create bin from: bin_location_floor_3{
			location <- location + {0,0,2*floor_loc_multiplier};
			floor_no <- 3;
            current_capacity <- 0.0;
            // set at 45L (450 units)
            max_capacity <- 30.0; //originally 45
            // set by slider, else 0.6 & 0.9
            ReadyToClear_capacity <- ReadyToClear_multiplier * max_capacity;
			AboutToBeFull_capacity<- AboutToBeFull_multiplier * max_capacity;
            ask central_bin{
            	myself.distance_to_central_bin <- self.location distance_to myself.location;
            }
		}
		
		
		create store_floor from: store_floor_3_file{
			floor_no <- 3;
			location <- location + {0,0,2*floor_loc_multiplier};
		}
		
		list store_spawn_list_lvl_3;
		
		loop store_spawn over:agent_spawn_locations_floor_3{
			store_spawn <- store_spawn.location + {0,0,2*floor_loc_multiplier};
			add store_spawn to:store_spawn_list_lvl_3;
		}
		
		loop store_spawn_loc over:store_spawn_list_lvl_3{
			
			create store with: (
				floor_file:store_floor_3_file,
				floor_no:3,
				text_loc_list:total_store_text_loc_list,
				location:store_spawn_loc,
				ped_path_for_floor:ped_list_floor_3
				
							
			);
			
		}
//////////////////////////////////////////// LEVEL 3 //////////////////////////////////////////
//////////////////////////////////////////// LEVEL 4 //////////////////////////////////////////
        // Create obstacles
        
        create obstacle from: wall_floor_4_shapefile{
        	floor_no <- 4;


        }

        create vida_lvl_layout_4 from: free_spaces_4_shape_file{
        	location <- location + {0,0,3*floor_loc_multiplier};
        }
        
        // Create stairs
        create stairs from: stairs_floor_4{
        	floor_no <- 4;
        	location <- location + {0,0,3*floor_loc_multiplier};
        }

				
		create bin from: bin_location_floor_4{
			location <- location + {0,0,3*floor_loc_multiplier};
			floor_no <- 4;
            current_capacity <- 0.0;
            // set at 45L (450 units)
            max_capacity <- 30.0; //originally 45
            // set by slider, else 0.6 & 0.9
            ReadyToClear_capacity <- ReadyToClear_multiplier * max_capacity;
			AboutToBeFull_capacity<- AboutToBeFull_multiplier * max_capacity;
            ask central_bin{
            	myself.distance_to_central_bin <- self.location distance_to myself.location;
            }
		}
		
		
		create store_floor from: store_floor_4_file{
			floor_no <- 4;
			location <- location + {0,0,3*floor_loc_multiplier};
		}
		
		list store_spawn_list_lvl_4;
		
		loop store_spawn over:agent_spawn_locations_floor_4{
			store_spawn <- store_spawn.location + {0,0,3*floor_loc_multiplier};
			add store_spawn to:store_spawn_list_lvl_4;
		}
		
		loop store_spawn_loc over:store_spawn_list_lvl_4{
			
			create store with: (
				floor_file:store_floor_4_file,
				floor_no:4,
				text_loc_list:total_store_text_loc_list,
				location:store_spawn_loc,
				ped_path_for_floor:ped_list_floor_4	

			);
			
		}
//////////////////////////////////////////// LEVEL 4 //////////////////////////////////////////

 		
 		
 		create stairwell{
 			stairwell_stairs <- [0, 6, 11, 14];
 		}
 		
 		create stairwell{
 			stairwell_stairs <- [2,8,13];
 		}
 		
 		create stairwell{
 			stairwell_stairs <- [1,7,12,15];
 		}
 		
 		create stairwell{
 			stairwell_stairs <- [4,9];
 		}
 		
 		create stairwell{
 			stairwell_stairs <- [5,10];
 		}
 		
    } // init close bracket
    
}


// Create central rubbish bin agent
species central_bin{
	
	aspect default {
		draw square(15) color: #cadetblue depth: 15;
	}
	
}

// Species for pedestrian paths
species pedestrian_path skills: [pedestrian_road] {
	int floor_no;
	
    
    aspect floor_1 {
 		if floor_no = 1{
 			draw shape color: #gray;
 		}
    }
    
    aspect floor_2 {
 		if floor_no = 2{
 			draw shape color: #gray;
 		}
    }
    
    aspect floor_3 {
 		if floor_no = 3{
 			draw shape color: #gray;
 		}
    }
    
    aspect floor_4 {
 		if floor_no = 4{
 			draw shape color: #gray;
 		}
    }
}

// Species for vidacity_lvl_1_outline
species vida_lvl_layout_1 {
    aspect default {
        draw shape color: #gray border: #black at:{location.x,location.y,location.z-0.1} perspective:false;
    }
}

species vida_lvl_layout_2 {
    aspect default {
        draw shape color: #gray border: #black at:{location.x,location.y,location.z-0.1} perspective:false;
    }
}

species vida_lvl_layout_3 {
    aspect default {
        draw shape color: #gray border: #black at:{location.x,location.y,location.z-0.1} perspective:false;
    }
}

species vida_lvl_layout_4 {
    aspect default {
        draw shape color: #gray border: #black at:{location.x,location.y,location.z-0.1} perspective:false;
    }
}

// Species for obstacles
species obstacle {
	int floor_no;


	aspect floor_1 {
		if floor_no = 1{
			draw shape + (0.45/2.0) color: #black depth: 10;
		}
	}
	aspect floor_2 {
		if floor_no = 2{
			draw shape + (0.45/2.0) at: {location.x,location.y,location.z + floor_loc_multiplier} color: #black depth: 10; // purely for visualisation
		}
	}
	aspect floor_3 {
		if floor_no = 3{
			draw shape + (0.45/2.0) at: {location.x,location.y,location.z + 2*floor_loc_multiplier} color: #black depth: 10; // purely for visualisation
		}
	}
	aspect floor_4 {
		if floor_no = 4{
			draw shape + (0.45/2.0) at: {location.x,location.y,location.z + 3*floor_loc_multiplier} color: #black depth: 10; // purely for visualisation
		} 
	}
}

// Species for stairs
species stairs {
	int floor_no;

	aspect floor_1 {
		if floor_no = 1{
			draw square(10) color: #black depth: 125;
		}
	}
	aspect floor_2 {
		if floor_no = 2 and index!=9 and index!= 10{
			draw square(10) color: #black depth: 125;
		}
		if index = 9 or index = 10{
			draw square(10) color: #black depth: 10;
		}
	}
	aspect floor_3 {
		if floor_no = 3 and index != 12{
			draw square(10) color: #black depth: 125;
		}
		if index = 12{
			draw square(10) color: #black depth: 10;
		}
	}
	aspect floor_4 {
		if floor_no = 4{
			draw square(10) color: #black depth: 10;
		}
	}
}

species stairwell {
	list stairwell_stairs;
	}

species store_floor {
	int floor_no;
	
	aspect floor_1 {
		if floor_no = 1{
			draw shape color: #orange;
		}
				
	}
	aspect floor_2 {
		if floor_no = 2{
			draw shape color: #orange;
		}
	}
	aspect floor_3 {
		if floor_no = 3{
			draw shape color: #orange;
		}
	}
	aspect floor_4 {
		if floor_no = 4{
			draw shape color: #orange;
		}
	}
}

// Species for trash bins
species bin {
	rgb bin_color <- #green;
	float max_capacity;
	float current_capacity <- 0.0;
	// Statuses: Empty, Filling, ReadyToClear, AboutToBeFull, Full
	string current_status <- "Empty";
	float ReadyToClear_capacity;
	float AboutToBeFull_capacity;
	float distance_to_central_bin;
	float current_distance_to_cleaner <- 0.0;
	int bin_width <- 6;
	int bin_displayTextSize <- displayTextSize-2;
	int floor_no;
	
	reflex check_bin_trash_level{
		
		// set different colours of bins based on threshold
		if (current_capacity >= 0.0 and current_capacity < ReadyToClear_capacity){
			current_status <- "Filling";
			bin_color <- #green;
		}
		
		else if (current_capacity >= ReadyToClear_capacity and current_capacity < AboutToBeFull_capacity){
			bin_color <- #yellow;
			current_status <- "ReadyToClear";
		}
		
		else if (current_capacity >= AboutToBeFull_capacity and current_capacity < max_capacity){
			bin_color <- #orange;
			current_status <- "AboutToBeFull";
		}
		
		
		else if (current_capacity >= max_capacity){
			bin_color <- #red;
			current_status <- "Full"; 
			total_time_bin_overflowed <- total_time_bin_overflowed + 1.0;
			weekly_duration_overflow_log <- weekly_duration_overflow_log + 1.0;
		}
		
	}
	
    
    aspect floor_1 {
		if floor_no = 1{
			draw square(bin_width) color: bin_color depth: bin_width;
		draw ("Bin " + self.index) color:#black size:bin_displayTextSize at:{location.x-3,location.y+bin_width*2-3,location.z} font:agent_font perspective:true;
		draw ("Fill: " + ((current_capacity*100)/100) with_precision 2)  color:#black size:bin_displayTextSize font:agent_font at:{location.x-3,location.y+bin_width*2+bin_displayTextSize*3.5,location.z} perspective:true;
		}
	}
	aspect floor_2 {
		if floor_no = 2{
			draw square(bin_width) color: bin_color depth: bin_width;
		draw ("Bin " + self.index) color:#black size:bin_displayTextSize at:{location.x-3,location.y+bin_width*2-3,location.z} font:agent_font perspective:true;
		draw ("Fill: " + ((current_capacity*100)/100) with_precision 2)  color:#black size:bin_displayTextSize font:agent_font at:{location.x-3,location.y+bin_width*2+bin_displayTextSize*3.5,location.z} perspective:true;
		}
	}
	aspect floor_3 {
		if floor_no = 3{
			draw square(bin_width) color: bin_color depth: bin_width;
		draw ("Bin " + self.index) color:#black size:bin_displayTextSize at:{location.x-3,location.y+bin_width*2-3,location.z} font:agent_font perspective:true;
		draw ("Fill: " + ((current_capacity*100)/100) with_precision 2)  color:#black size:bin_displayTextSize font:agent_font at:{location.x-3,location.y+bin_width*2+bin_displayTextSize*3.5,location.z} perspective:true;
		}
	}
	aspect floor_4 {
		if floor_no = 4{
			draw square(bin_width) color: bin_color depth: bin_width;
		draw ("Bin " + self.index) color:#black size:bin_displayTextSize at:{location.x-3,location.y+bin_width*2-3,location.z} font:agent_font perspective:true;
		draw ("Fill: " + ((current_capacity*100)/100) with_precision 2)  color:#black size:bin_displayTextSize font:agent_font at:{location.x-3,location.y+bin_width*2+bin_displayTextSize*3.5,location.z} perspective:true;
		}
	}
}

species store{
	list text_loc_list;
	point text_loc <- (text_loc_list at self.index);
	int tenant_no <- (total_tenant_list at self.index);
	list<agent> tenants_in_store;
	int current_tenants_in_store;
	float store_bin <- 0.0;
	float store_bin_clear_threshold <- 3.0;
	int store_size <- 20;
	int floor_no;
	file floor_file;
	geometry store_area <- rectangle({location.x-(store_size/2),location.y-(store_size/2)}, {location.x+(store_size/2),location.y+(store_size/2)});
	list ped_path_for_floor;
	geometry spawn_pts <- ped_path_for_floor first_with (each intersects store_area and any(store_floor) covers (each));
	
	init{
				
//		write"SPAWN POINTS: " + spawn_pts;
//		
//		write "my tenant nummber is: " + tenant_no;
		


		create people number:tenant_no{
	        name <- ("Tenant " + host.index + "." + self.index);
	        location <- any_location_in(spawn_pts);
	        has_trash <- false;
	        trash_on_hand<- 0.0;
	        home_base <- location;
            
//          if (step = 1#minute){
//            //write" T is" + T + "for minutes";
//          }
//          else if (step = 1#second){
//            T<- T*60;
//            //write" T is" + T + "for seconds";
//          }
       }
		
	}
		
	
	
	reflex refresh_agent_in_store_count{
		
		ask agents {
				
				
				if (myself.store_area covers(self.location)) and !(myself.tenants_in_store contains self) {
					myself.tenants_in_store <- 	myself.tenants_in_store + self;
					
				}
				
				else if !(myself.store_area covers(self.location)) and (myself.tenants_in_store contains self){
					myself.tenants_in_store <- 	myself.tenants_in_store - self;
				}

			
		}
		
		current_tenants_in_store <- length(tenants_in_store);
		
	}
	
	
	aspect floor_1 {
		if floor_no = 1{
			draw square(store_size) color: #burlywood at:{location.x,location.y, location.z-1} ;
			draw ("Store " + self.index) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+5+displayTextSize,text_loc.z} perspective:true;
			draw (": " + current_tenants_in_store + "/" + tenant_no) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+12+displayTextSize,text_loc.z} perspective:true;
			draw ("Fill: " + string(store_bin with_precision 2) + "/" + int(store_bin_clear_threshold)) color: #black font:agent_font size: displayTextSize at: {text_loc.x +5 ,text_loc.y +24,text_loc.z} perspective:true;
		}
	}
	aspect floor_2 {
		if floor_no = 2{
			draw square(store_size) color: #burlywood at:{location.x,location.y, location.z-1} ;
			draw ("Store " + self.index) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+5+displayTextSize,text_loc.z} perspective:true;
			draw (": " + current_tenants_in_store + "/" + tenant_no) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+12+displayTextSize,text_loc.z} perspective:true;
			draw ("Fill: " + string(store_bin with_precision 2) + "/" + int(store_bin_clear_threshold)) color: #black font:agent_font size: displayTextSize at: {text_loc.x +5 ,text_loc.y +24,text_loc.z} perspective:true;
		}
	}
	aspect floor_3 {
		if floor_no = 3{
			draw square(store_size) color: #burlywood at:{location.x,location.y, location.z-1} ;
			draw ("Store " + self.index) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+5+displayTextSize,text_loc.z} perspective:true;
			draw (": " + current_tenants_in_store + "/" + tenant_no) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+12+displayTextSize,text_loc.z} perspective:true;
			draw ("Fill: " + string(store_bin with_precision 2) + "/" + int(store_bin_clear_threshold)) color: #black font:agent_font size: displayTextSize at: {text_loc.x +5 ,text_loc.y +24,text_loc.z} perspective:true;
		}
	}
	aspect floor_4 {
		if floor_no = 4{
			draw square(store_size) color: #burlywood at:{location.x,location.y, location.z-1} ;
			draw ("Store " + self.index) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+5+displayTextSize,text_loc.z} perspective:true;
			draw (": " + current_tenants_in_store + "/" + tenant_no) font:agent_font color:#black size:displayTextSize at:{text_loc.x+5,text_loc.y+12+displayTextSize,text_loc.z} perspective:true;
			draw ("Fill: " + string(store_bin with_precision 2) + "/" + int(store_bin_clear_threshold)) color: #black font:agent_font size: displayTextSize at: {text_loc.x +5 ,text_loc.y +24,text_loc.z} perspective:true;
		}
	}
	




	// Species for people with pedestrian skill
	species people skills: [pedestrian,moving]{
		
		
		float trash_generation_lambda;
		float trash_on_hand;
	    
	    rgb color <- rnd_color(255);
	    float speed <- 3 #km/#h; //0.05 #km/#h; //should be 4km/h irl, this is just for visualisation
	    bin target_bin;
	    point current_target;
	    point home_base;
		path path_to_bin;
		int len_path_to_bin;
		bool has_trash;
		int floor_no <- host.floor_no;
		int indice_selector <- floor_no-1;
		list<bin> same_floor_bin_list;
		list<agent> current_floor_stairs_list;
    	agent same_floor_stairs_target;
		agent first_floor_stairs_target <- nil;
		bool ready_for_work <- true;
		bool init_tenant_bool <- true;
		
		
	    
	 
		
    ///////////////////////    START NHPP    /////////////////////   START  NHPP    /////////////////////    START NHPP    /////////////////////


	  float mean_trash_amount <- 0.3;
      float sd_trash_amount <- 0.01;
           
      float trash_generated_now;
      list<float> intensity_values <- []; // stores intensity fn values for visualisation
      
      list daily_trash_log;
      
      int random_pattern <- rnd(2); // returns 0, 1 or 2
      
//      int T <- 1440; // minutes, the below function will change it to seconds when necessary
      
      // without dividing /60 it is all per minute
      
      //  h1 = h2
      float base_rate_0 <- 0.001918;
      float amp1_0 <- 0.018495;
      float center1_0 <- 690.0;
      float amp2_0 <- 0.018495;
      float center2_0 <- 870.0;
      float fixed_width_0 <- 60.0;    
      
      //  h1 > h2
      float base_rate_1 <- 0.002240;
      float amp1_1 <- 0.13870;
      float center1_1 <- 690.0;
      float amp2_1 <- 0.010130;
      float center2_1 <- 870.0;
      float fixed_width_1 <- 60.0;

      // h1 < h2
      float base_rate_2 <- 0.002980;
      float amp1_2 <- 0.011835;
      float center1_2 <- 690.0;
      float amp2_2 <- 0.015421;
      float center2_2 <- 870.0;
      float fixed_width_2 <- 60.0;

    
    float lambda_t (float t, float base_rate, float amp1, float center1, float amp2, float center2, float fixed_width) {
      
        //only center1, center2 and fixed_width to * 60, the rest /60 if step = seconds 
        if (step = 1#minute){
          float intensity <- base_rate;
          intensity <- intensity + amp1 * exp((-1)*((t-center1)^2)/((2*(fixed_width)^2)));
          intensity <- intensity + amp2 * exp((-1)*((t-center2)^2)/((2*(fixed_width)^2)));
          //write " step is 1 minutes";
          return max(0,intensity);
        }
        else if (step = 1#second){
          float intensity <- base_rate/60;
          intensity <- intensity + (amp1/60) * exp((-1)*((t-(center1*60))^2)/((2*(fixed_width*60)^2)));
          intensity <- intensity + (amp2/60) * exp((-1)*((t-(center2*60))^2)/((2*(fixed_width*60)^2)));
          //write " step is 1 secd";
          return max(0,intensity);
          
        }
        
      
      }
      
 
      
      
      action find_stairs_belonging_to_me{
      	
      	// if tenant not already on floor 1
      	if self.floor_no != 1{
	      	current_floor_stairs_list <- [];
			
			ask stairs{
				if self.floor_no = myself.floor_no{
					add self to:myself.current_floor_stairs_list;
				}
			}
					
			
			current_floor_stairs_list <- current_floor_stairs_list sort_by (each distance_to self); // sort from shortest distance to self
			// set current_target to nearest stairwell when returning to rest (all stairs go to lvl 1)
			
			//skip the stairs at top floor
			if (self.current_floor_stairs_list at 0).index = 16{
				same_floor_stairs_target <- (current_floor_stairs_list at 1);
			}
			else{
				same_floor_stairs_target <- (current_floor_stairs_list at 0);
				
			}
						
			
			
			
			ask stairwell{
				
				
				if self.stairwell_stairs contains myself.same_floor_stairs_target.index{
					
					myself.first_floor_stairs_target <- stairs(self.stairwell_stairs at 0);
				}
	
			
			}
			
			
//			first_floor_stairs_target <- {same_floor_stairs_target.location.x,same_floor_stairs_target.location.y,0};
			
		}
      }
      
      
      action init_tenant_at_entrance{
      	self.location <- entrance;
      	self.init_tenant_bool <- false;
      	self.ready_for_work <- false;
      	self.floor_no <- 1;
      }
      
      
      
      reflex move_out when: (current_date.hour >= 20 or current_date.hour < 6) and ready_for_work = true{
      	
      	if self.first_floor_stairs_target = nil{
      		do find_stairs_belonging_to_me;
      	}
      	
      	if self.init_tenant_bool = true {
      		do init_tenant_at_entrance;
      	}
      	
//      	write "MOVE OUT";
      	
      	if self.floor_no != 1{
      		if self.location distance_to same_floor_stairs_target > 0.1{
      			do goto (target: same_floor_stairs_target, on: pedestrian_network_list at indice_selector);
      		}
      		
      		else{
      			//teleport to lvl 1
      			self.location <- self.first_floor_stairs_target.location;
      			self.floor_no <- 1;
      		}
      	}
      	
      	else{
      		if self.location distance_to entrance > 0.1{ 
      			do goto (target: entrance, on: pedestrian_network_list at 0);
      		}
      		else{
      			self.location <- entrance;
      			self.floor_no <- 1;
      			ready_for_work <- false;
      		}
      		
      	}
      	
      	
      	
      }
      

      
      reflex move_in  when: (current_date.hour >= 6 and current_date.hour < 20) and ready_for_work=false{
      	
//      	write "MOVEIN";
      	
      	if self.location distance_to self.home_base >= 1{
      		
      		//store not on first floor
      		if self.floor_no = 1  and self.host.floor_no != 1{
      			if self.location distance_to self.first_floor_stairs_target > 0.1{
      				do goto (target: self.first_floor_stairs_target, on: pedestrian_network_list at 0);
      			}
      			else{
//      				write "REACHED SAME FLOOR STAIRS";
      				//teleport to respective stairs
	      			self.location <- self.same_floor_stairs_target.location;
	      			self.floor_no <- self.host.floor_no;
      			}
      		}
      		else{
      			do goto (target: self.home_base, on: pedestrian_network_list at indice_selector);
      		}

      	}
      
      	
      	else{
      		self.location <- self.home_base;
      		ready_for_work<-true;
      	}
      	
      }
          
      reflex default when: (self.location distance_to home_base < 1) and has_trash = false {
        do create_trash;
        store_bin <- store_bin + trash_generated_now;
        // trash_on_hand <- trash_on_hand + trash_generated_now;
        
        if (store_bin >= store_bin_clear_threshold){
            has_trash <- true;
            trash_on_hand <- store_bin;
            
            // transfered trash to tenant hand
            store_bin <- 0.0;
            do search_target;
          }
       
      }
      
      
      
      action create_trash {
        
        //create people in store species will update T to equal to 1440 in minutes or 86400 if simulation is in seconds
        float t <- float(cycle mod T);
        float intensity_at_t;
      // write "random pattern chosen is" + random_pattern;
      if (random_pattern = 0){
        intensity_at_t <- lambda_t(t, base_rate_0,  amp1_0, center1_0, amp2_0, center2_0, fixed_width_0);
      } 
      else if (random_pattern = 1){
        intensity_at_t <- lambda_t(t, base_rate_1,  amp1_1, center1_1, amp2_1, center2_1, fixed_width_1);
      }
      else if (random_pattern = 2){
        intensity_at_t <- lambda_t(t, base_rate_2,  amp1_2, center1_2, amp2_2, center2_2, fixed_width_2);
      }
        
          float candidate <- rnd(0.0,1.0);
          float acceptance_prob <- 1-exp((-1)*(intensity_at_t));
          if (candidate < acceptance_prob) { 
                 trash_generated_now <- gauss(mean_trash_amount, sd_trash_amount);
                 if (step = 1#minute){
              //write "Generated trash at: " + (t /60) with_precision 2 + " (hours) by agent in: " + self.host;  
            }
            else if (step = 1#second){
				//write "Generated trash at: " + (t /3600) with_precision 2 + " (hours) by agent in: " + self.host;  
            }
                 
        }
        else{
        	
          trash_generated_now <- 0.0;
          
        }
      }
	    
    ///////////////////////   END NHPP    /////////////////////   END NHPP    /////////////////////   END NHPP    /////////////////////
		
		
		
	    
	    // Find target bin if none is set and if the agent has trash
	    action search_target {
	    	ask bin{
	    		if self.floor_no = myself.floor_no{
	    			myself.same_floor_bin_list <- myself.same_floor_bin_list + self;
	    		}
	    	}
			ask self.same_floor_bin_list closest_to(self) {
				    	// write "my target is: " + self + "i am:" + myself;
			        	
			            myself.target_bin <- self;
			            myself.current_target <- self.location;
			        }
	    }
	    
	    
	    reflex move when: current_target != nil {
	    	
	    	
	    	//in tenant store chilling
	    	if not has_trash and current_target = home_base{
	    		if self.location distance_to home_base < 0.1 {
		            current_target <- nil;
	//	            write name + " has reached home! Time to make trash...";
		        }
	        //go back to store
	        else{
	           do goto (target: home_base, on: pedestrian_network_list at indice_selector);
			}
	    		
	    		
	    		
	    	}
	    	//disposing of trash
	    	if has_trash and current_target = target_bin.location{
	    		
	    		
	    		if self.location distance_to target_bin.location < 0.1 {
	    			
	    			//add complaint?
	    			if target_bin.current_status = "Full"{
	    				
	    				total_complaints <- total_complaints + 1;
	    				weekly_complain_log <- weekly_complain_log +1;
	    			}
	    			
		  			target_bin.current_capacity <- (target_bin.current_capacity + trash_on_hand); 
		            has_trash <- false;
		            trash_on_hand <- 0.0;
		            current_target <- home_base;
	//	            write name + " has reached the bin!";
		        }
		    //walking to bin
	        else{
	            do goto (target: target_bin.location, on: pedestrian_network_list at indice_selector);
	//			  do goto (target: target_bin.location);
	            
	            
			}
	     }
	    		
	    }
	    	
	   
	    aspect floor_1 {
			if floor_no = 1 and current_date.hour >= 5 and current_date.hour < 21{
//			if floor_no = 1{
				if has_trash{
					draw string("Trash: " + (trash_on_hand with_precision 2)) font:agent_font color:#black size:displayTextSize at:{location.x-10,location.y+displayTextSize*4,location.z} perspective:true; 
		    	}
		        
		        draw triangle(5) color: color rotate: heading + 90.0 depth: 3;
		        
//		        if (current_path != nil) {
//					//draw current_path.shape color: #red;
//				}
			}
		}
		aspect floor_2 {
			if floor_no = 2 and current_date.hour >= 5 and current_date.hour < 21{
//				if floor_no = 2{
				if has_trash{
					draw string("Trash: " + (trash_on_hand with_precision 2)) font:agent_font color:#black size:displayTextSize at:{location.x-10,location.y+displayTextSize*4,location.z} perspective:true; 
		    	}
		        
		        draw triangle(5) color: color rotate: heading + 90.0 depth: 3;
		        
//		        if (current_path != nil) {
//					//draw current_path.shape color: #red;
//				}
			}
		}
		aspect floor_3 {
			if floor_no = 3 and current_date.hour >= 5 and current_date.hour < 21{
//				if floor_no = 3{
				if has_trash{
					draw string("Trash: " + (trash_on_hand with_precision 2)) font:agent_font color:#black size:displayTextSize at:{location.x-10,location.y+displayTextSize*4,location.z} perspective:true; 
		    	}
		        
		        draw triangle(5) color: color rotate: heading + 90.0 depth: 3;
		        
//		        if (current_path != nil) {
//					//draw current_path.shape color: #red;
//				}
			}
		}
		
		aspect floor_4 {
			if floor_no = 4 and current_date.hour >= 5 and current_date.hour < 21{
//				if floor_no = 4{
				if has_trash{
					draw string("Trash: " + (trash_on_hand with_precision 2)) font:agent_font color:#black size:displayTextSize at:{location.x-10,location.y+displayTextSize*4,location.z} perspective:true; 
		    	}
		        
		        draw triangle(5) color: color rotate: heading + 90.0 depth: 3;
		        
//		        if (current_path != nil) {
//					draw current_path.shape color: #red;
//				}
			}
		}
	}
	
}
	
species visitor skills:[moving,pedestrian]{
	//geometry free_space <- pedestrian_network_1 first_with (each covers open_area);
	float trash_on_hand <- 0.0;
	point bin_in_path;
	bin target_bin;
	point visitor_target;
	list<point> target_list <- nil;
	point next_destination;
	float trash_on_hand_capacity <- 0.3;
	bool alive <- true;
	point entrance;
	
	int current_floor_no <- 1;
	list<agent> current_floor_stairs_list;
	agent current_stairwell;
	stairs target_stairs;
	int target_floor;
	list floors <- [0,1,2,3];
	list temporary_floors;
	float speed <- 3 #km/#h;
	point next_level_stairs;
	float check_stairs;
	bool straggler;
	int lifespan;
	
	
    	float mean_trash_amount <- 0.3;
	    float sd_trash_amount <- 0.01;
	    	   
	    float trash_generated_now;
	    list<float> intensity_values <- []; // stores intensity fn values for visualisation
	    
	    list daily_trash_log;
	    
	    int random_pattern <- rnd(2); // returns 0, 1 or 2
	    
//	    int T <- 1440; // minutes, the below function will change it to seconds when necessary
	    
	
	
	
	reflex default when: alive = true{

	    // Generate trash each step
	    do create_trash;
	    
	
	    // If holding trash and no current target bin, look for nearby bin
	    if (trash_on_hand > trash_on_hand_capacity and target_bin = nil) {
	        ask bin {
	            if (self.location distance_to myself.location < 100) {
	                myself.target_bin <- self;
	                // Insert bin as top priority in the route   
	                add item: myself.target_bin.location to: myself.target_list at:0;
//	                write "Added bin to target list, target_list is: " + myself.target_list;
	                if myself.location in myself.target_list{
	                	remove item: myself.location from: myself.target_list;
//	                	write "already at destination (index 1 of target list) before reaching bin at index 0 of target_list";
	                }
	            }
	        }
	    }    
	
	    // If near any bin, dump trash
	    if (target_bin != nil and location = target_bin.location) {
	        if (target_bin.current_status = "Full") {
	            total_complaints <- total_complaints + 1;
	            weekly_complain_log <- weekly_complain_log +1;
	        }
	        target_bin.current_capacity <- target_bin.current_capacity + trash_on_hand;
	        trash_on_hand <- 0.0;
	        target_bin <- nil;
//	        write "disposed of trash";
	    }
	    
	    // If near any stairwell, add to target_list
	    if (target_stairs = nil and length(target_list) <= 1){
	    	check_stairs <- rnd(0.0,1.0);
	    	if check_stairs < 0.3{
	    		ask stairs{
		    		if (self.location distance_to myself.location < 50 and not(self.location in myself.target_list) and self.index != 16){
		    			myself.target_stairs <- self;
		    			add item: myself.target_stairs.location to: myself.target_list;
//		    			write "found stairs to climb, target_list is: " + myself.target_list;
		    		}
	    		}	    	
	    	}
	    }
	    
	    // Bounding the available levels it can traverse to based on staircase index
	    if (target_stairs != nil and location = target_stairs.location and location = target_list at 0){
//			write "reached stairs, awaiting removal from target_list";
			if target_stairs.index in [0,6,11,14,1,7,13,15]{
				target_floor <- one_of([1,2,3,4]);
				do decide_floor;
			}
			else if target_stairs.index in [2,8,12]{
				target_floor <- one_of([1,2,3]);
				do decide_floor;
			}
			else if target_stairs.index in [3,4,9,5,10]{
				target_floor <- one_of([1,2]);
				do decide_floor;
			}
			visitor_target <- any(pedestrian_network_list at (current_floor_no -1));
	    	target_list <- target_list + visitor_target;  
//	    	write "Added wandering point after stairs, target list is: " + target_list;
	    	
	    	target_stairs <- nil;
	        target_floor <- nil;
	    	next_level_stairs <- nil;
	    	
	    	
//	    	write "Remove awaited base stairs in next print" + target_list;
	    	
			
	    }
	   
	
	    // Movement logic, basic using the target_list and getting it at index 0
	    if (length(target_list) > 0) {
	    	//write "Target list is now: " + target_list;
	        next_destination <- target_list at 0;
	
	        if (location != next_destination) {
	            do goto (target: next_destination, on: pedestrian_network_list at (current_floor_no-1));
	        } 
	        else {
	            // Reached a target point
	            remove item: next_destination from: target_list;
//	            write"Removed item from target list, target list is now: " + target_list;
	        }
	    } 
	    
	    else if length(target_list)=0{
	        // Pick a new destination
	        visitor_target <- any(pedestrian_network_list at (current_floor_no -1));
	        target_list <- target_list + visitor_target;
//	        write "Added wandering point, target list is: " + target_list;    
	     
	    }
	}

	action decide_floor{
		
//			write"target floor: " + target_floor + " current floor: " + current_floor_no;
			if target_floor < current_floor_no{
	    		next_level_stairs <- {location.x, location.y, location.z - ((current_floor_no - target_floor)*floor_loc_multiplier)};
	    		current_floor_no <- target_floor;	    		
	    	}
	    	else if target_floor > current_floor_no{
	    		next_level_stairs <- {location.x, location.y, location.z + ((target_floor - current_floor_no)*floor_loc_multiplier)};
	    		current_floor_no <- target_floor;
	    	}
	    	else{
	    		next_level_stairs <- target_stairs.location;
	    	}
	    	if alive = true{
	    		add item: next_level_stairs to: target_list;
	    		//current_floor_no <- target_floor;
//	    		write"Added next level stairs to target list, target_list is: " + target_list;
	    	}
	    	if alive = false{
//	    		write "Next_level_stairs aka target is: " + next_level_stairs + " which should be at level 1";
	    	}
	    	location <- next_level_stairs;
//	    	write "transported to the destination level at: " + location;
	 
		}
    	
	    // without dividing /60 it is all per minute
	    
	    //	h1 = h2
	    float base_rate_0 <- 0.001918;
	    float amp1_0 <- 0.018495;
	    float center1_0 <- 690.0;
	    float amp2_0 <- 0.018495;
	    float center2_0 <- 870.0;
	    float fixed_width_0 <- 60.0;    
	    
	    //	h1 > h2
	    float base_rate_1 <- 0.002240;
	    float amp1_1 <- 0.13870;
	    float center1_1 <- 690.0;
	    float amp2_1 <- 0.010130;
	    float center2_1 <- 870.0;
	    float fixed_width_1 <- 60.0;

	    // h1 < h2
	    float base_rate_2 <- 0.002980;
	    float amp1_2 <- 0.011835;
	    float center1_2 <- 690.0;
	    float amp2_2 <- 0.015421;
	    float center2_2 <- 870.0;
	    float fixed_width_2 <- 60.0;

		
		float lambda_t (float t, float base_rate, float amp1, float center1, float amp2, float center2, float fixed_width) {
    	
    		//only center1, center2 and fixed_width to * 60, the rest /60 if step = seconds 
    		if (step = 1#minute){
	    		float intensity <- base_rate;
		    	intensity <- intensity + amp1 * exp((-1)*((t-center1)^2)/((2*(fixed_width)^2)));
		    	intensity <- intensity + amp2 * exp((-1)*((t-center2)^2)/((2*(fixed_width)^2)));
		    	//write " step is 1 minutes";
		    	return max(0,intensity);
    		}
    		else if (step = 1#second){
	    		float intensity <- base_rate/60;
		    	intensity <- intensity + (amp1/60) * exp((-1)*((t-(center1*60))^2)/((2*(fixed_width*60)^2)));
		    	intensity <- intensity + (amp2/60) * exp((-1)*((t-(center2*60))^2)/((2*(fixed_width*60)^2)));
		    	//write " step is 1 secd";
		    	return max(0,intensity);
    			
    		}
	    	
    	
    	}
    	
    	action create_trash {
    		
    		//create people in store species will update T to equal to 1440 in minutes or 86400 if simulation is in seconds
    		float t <- float(cycle mod T);
    		float intensity_at_t;
			// write "random pattern chosen is" + random_pattern;
			if (random_pattern = 0){
				intensity_at_t <- lambda_t(t, base_rate_0,  amp1_0, center1_0, amp2_0, center2_0, fixed_width_0);
			} 
			else if (random_pattern = 1){
				intensity_at_t <- lambda_t(t, base_rate_1,  amp1_1, center1_1, amp2_1, center2_1, fixed_width_1);
			}
			else if (random_pattern = 2){
				intensity_at_t <- lambda_t(t, base_rate_2,  amp1_2, center1_2, amp2_2, center2_2, fixed_width_2);
			}
    		
	        float candidate <- rnd(0.0,1.0);
	        float acceptance_prob <- 1-exp((-1)*(intensity_at_t));
	        if (candidate < acceptance_prob) { 
	               trash_generated_now <- gauss(mean_trash_amount, sd_trash_amount);
	               trash_on_hand <- trash_on_hand + trash_generated_now;
	               
	               if (step = 1#minute){
		    			//write "Generated trash at: " + (t /60) with_precision 2 + " (hours)";	
		    		}
		    		else if (step = 1#second){
		    			//write "Generated trash at: " + (t /3600) with_precision 2 + " (hours)";	
		    		}
	               
    		}
    		else{
    			trash_generated_now <- 0.0;
    			trash_on_hand <- trash_on_hand + trash_generated_now;
    		}
    	}

	
	  reflex count_lifespan when: every(1#hour){
	  	if self.straggler = true{
	   	 self.lifespan <- self.lifespan + 1;
	    
	    }
	  }
	
	  reflex begin_unalive_event when: current_date.hour = 17 and straggler = false{
	    alive <- false;
	    //write "Time to leave";
	    do unalive;
	  }
	    
	  reflex begin_unalive_straggler when: lifespan = 3 and straggler = true{
	    alive <- false;
	    //write "Time to leave";
	    do unalive;
	  }

	
	action unalive{ 
		target_list <- nil;
		next_destination <- nil;
		target_floor <- 1;
//		write "Unaliving, target list is: " + target_list;
		if (location distance_to entrance > 0.1) {
			if current_floor_no != 1{
				ask stairs{
					if self.floor_no = myself.current_floor_no{
						add self to:myself.current_floor_stairs_list;	
						myself.target_stairs <- myself.current_floor_stairs_list closest_to myself;
					}				
				}
//				write "Heading to Target stairs: "+ target_stairs + " at " + target_stairs.location + " I am currently at: " + location;
				do goto (target: target_stairs.location, on: pedestrian_network_list at (current_floor_no-1));
//				write "Heading to Target stairs: "+ target_stairs + " at " + target_stairs.location + " I am currently at: " + location;
				
				if location = target_stairs.location{
					do decide_floor;
	            	do goto (target: entrance, on: pedestrian_network_list at (current_floor_no-1));

				}
//				next_level_stairs <- {location.x, location.y, location.z - ((current_floor_no - target_floor)*floor_loc_multiplier)};
//				
//				write "Next level stairs to go home is: " + next_level_stairs;
//	    		current_floor_no <- target_floor;
//	    		location <- next_level_stairs;
//	    		write "Arrived at floor 1";
	            
	        }
	        else{
	        	do goto (target: entrance, on: pedestrian_network_list at (current_floor_no-1));
	        	
	        }
	    } 
	    else {
//	    	write "Reached entrance " + location;		
			do die;
		}	
			
	}
	
	aspect default{
		if straggler = true{
		//draw (string("Trash on-hand: " + round(trash_on_hand*100)/100)) + " On Floor: "+ current_floor_no font:agent_font color:#black size:displayTextSize at:{location.x-10,location.y+displayTextSize*4, location.z} perspective:false; 
		draw sphere(1) color: #snow rotate: heading + 90.0 depth: 6;
	
		}
		else
		{
		draw sphere(1) color: #snow rotate: heading + 90.0 depth: 6;
		
		}
	}
}
	


species cleaner skills:[pedestrian]{
	bool is_cleaning <- false;
	float trash_on_hand;
	float max_trash_capacity;
	point current_target;
	int readyCount;
	point resting_location;
	float speed <- 4 #km/#h; //0.0666 #km/#h; //should be 3km/h irl, this is just for visualisation
    bool return_to_rest <- false;
    point central_bin_location;
    bin bin_to_clean;
	list<bin> readyBins <- [];
	list<bin> BinsAboutToBeFull <- [];
	list<bin> bins_to_clean_order;
	list<point> route <- [resting_location];
	list<float> distance;
	float total_time_travelled; //in seconds
	int current_floor_no <- 1;
	list<agent> current_floor_stairs_list;
	agent current_stairwell;
	
	bool trigger <- false;
	bool check <- true;
	
	// is clearing, return to rest, check
	// check for clearing when false, false, true
	// trigger clearing: true, false, false
	// clearing when true, false, false
	// at dumpster: false, true, false
	// return to rest when false, true, false
	// return to rest : false, false, true
	// actually rest: false, false, true
	
	
	action find_nearest_available_staircase{
		
		current_floor_stairs_list <- [];
		
		ask stairs{
			if self.floor_no = myself.current_floor_no{
				add self to:myself.current_floor_stairs_list;
			}
		}
				
		
		current_floor_stairs_list <- current_floor_stairs_list sort_by (each distance_to self); // sort from shortest distance to self
		// set current_target to nearest stairwell when returning to rest (all stairs go to lvl 1)
		
		//skip the stairs at top floor
		if (current_floor_stairs_list at 0).index = 16 and bin_to_clean = nil{
			// go to the next nearest stairs
			current_target <- (current_floor_stairs_list at 1).location;
		}
		else if (bin_to_clean = nil){
			current_target <- (current_floor_stairs_list at 0).location;
				//write "MY CURRENT STAIRS TARGET IS: " + current_floor_stairs_list at 0;
			
		}
		
		// if finding nearest stairwell during cleaning
		else if bin_to_clean != nil{
			current_target <- nil;
			
			// for each stairs_object (closest first)  on the cleaner's current floor
			loop stairs_object over:current_floor_stairs_list {
				// obj referenced in loop: stairs (self)
				//find the respective stairwell and check if the stairs can bring the cleaner to bin_to_clean.floor_no

				ask stairwell{
					
					if self.stairwell_stairs contains stairs_object.index and length(self.stairwell_stairs) >= myself.bin_to_clean.floor_no{
						myself.current_target <- stairs_object.location;
						
					}
					
				}
				
				if self.current_target != nil{
					//write "Current target (w/ bin_to_clean): "+ stairs_object;
					break; // breaks out of the stairs in current_floor_stairs_list loop
				}
				
				//else continue looping through stairs on current floor, that can bring cleaner to the current_bin's floor

				
			}
			
		}
		
		//write "MY CURRENT TARGET LOC IS: " + current_target;
		
		
	}
 

	reflex add_bins_to_activated_list when: check = true{

		
		//write "add bins to activated";

		ask agents of_species bin{
			
	 		// for each bin, if bins not inside readyBins list yet, add the bin into the list.
	 		if (self.current_status = "ReadyToClear" or self.current_status = "Full" or self.current_status = "AboutToBeFull"){
	 			if (myself.readyBins contains self = false){
	 				myself.readyBins <- myself.readyBins + self;
	 				
	 			}
	 		}
	 		
	 		// for each bin, check if they are about to be full, if so, trigger cleaning fn on readyBins
	 		if ( self.current_status = "Full" or self.current_status = "AboutToBeFull"){
	 			if (myself.BinsAboutToBeFull contains self = false){
	 				myself.BinsAboutToBeFull <- myself.BinsAboutToBeFull + self;
	 				
	 			}
	 		}
	 	}	 
	 	
	 	
	 	readyCount <- length(readyBins);
	 	   
	 	//write "Ready bin count: " + readyCount;
	 	
	 	// sort cleaning order and activate cleaner
	 	if (readyCount >= 2) or (length(BinsAboutToBeFull) > 0){
//	 		write" ready count is: " + readyCount + "and BinsAboutToBeFull is: " + BinsAboutToBeFull;
	 		trigger <- true;
	 		check <- false;
	 		do trigger_clean;
	 		daily_cleaner_trigger_count <- daily_cleaner_trigger_count + 1;
	 		
	 	}
	 	else if ((self.location distance_to resting_location) > 0.1){
	 		
	 		if current_floor_no != 1 and current_target = nil{
	 			do find_nearest_available_staircase;
	 		}
	 		
	 		else if(current_floor_no != 1 and current_target != nil) { // walk to nearest staircase of current floor, all stair wells go to lvl 1
	 			
	 			if self distance_to current_target > 0.1{
	 				do goto (target:current_target, on:pedestrian_network_list at (current_floor_no-1));
					total_time_travelled <- total_time_travelled + 1;
	 				
	 			}
	 			
	 			//cleaner reached stairs, teleport to floor 1.
	 			else{
	 				// teleport to floor 1
	 				self.location <- {current_target.location.x, current_target.location.y, 0};
	 				self.current_floor_no <- 1;
	 				self.current_target <- nil;
	 			}
	 		}
	 		else{
	 			// if on floor 1
				do goto (target:resting_location, on:pedestrian_network_list at (current_floor_no-1));
				total_time_travelled <- total_time_travelled + 1;
			
			}
		}
	 		
	 }

	 	
	 	
	 	
	
	
	action trigger_clean{
		//write "action trigger clean";
		trigger <- false;
		
		// if there is only 1 bin to be cleared, a.k.a bin abt to be full,
		if length(readyBins) = 1 {
			bins_to_clean_order <- readyBins;
		}
		
		
		// if 2 bins on diff lvl
		else{
			
			bins_to_clean_order <- reverse(readyBins sort_by (each.floor_no));
			
			// if bins are on the same floor, sort by distance from self; reversed
			if (bins_to_clean_order at 0).floor_no = (bins_to_clean_order at 1).floor_no{
				bins_to_clean_order <- reverse(bins_to_clean_order sort_by (each distance_to self));
			}
		
		}
		
		//write "Length of bins to clear: " + length(bins_to_clean_order);
		
		
		
//	    loop i over: bins_to_clean_order{
//	    	route <- route + i.location;
//	    }
//		do get_central_bin_location;
//		route <- route + central_bin_location + resting_location;
	            
//	            loop i over: route{
//	            distance <- distance + count(edge_between(pedestrian_network, i:: i+1));
//	            
//	            }
       //write "Cleaner activated! Cleaning bins..." ;
       //write "Route is " + route;
       //write "Distance list is: " + distance;
       //write "Total Route distance: " + sum(distance);
       
       
       
	            
	   is_cleaning <- true;
	   return_to_rest <- false;	        	
	}

	action get_central_bin_location{
		//write "get dumpster location";
		ask central_bin{
			myself.central_bin_location <- self.location;
		}
	}      

  
	            
	reflex clean_bins when: is_cleaning = true and return_to_rest = false and check = false{
		

        
        if (length(bins_to_clean_order) > 0 and location distance_to (bins_to_clean_order at 0) > 1){
        	bin_to_clean <- bins_to_clean_order at 0;
//			write "Cleaning " + bin_to_clean + "now!";    

			// if bin_to_clean is not on the same floor as the cleaner,
			if bin_to_clean.floor_no != self.current_floor_no{
				
				// if the cleaner does not know which stairs to go to
				if current_target = nil{
	 				do find_nearest_available_staircase;
	 			}
	 			
	 			// if current_target (stairs) is true:
	 			
	 			
	 			
 				// if stairs is stairs 2
	 			if current_target=stairs(1).location{
	 				
	 				
	 				if (current_target != nil  and self distance_to current_target > 20) {
		 				
		 				//write "moving to stairs of index for STAIRS 2: " + current_target;
		 				//write (self distance_to current_target);
		 				
		 				do goto (target:current_target, on:pedestrian_network_list at (self.current_floor_no-1));
	//	 				do goto (target:current_target);
		 				
						total_time_travelled <- total_time_travelled + 1;
		 				
		 			}
		 			
	//	 			else {
		 			else if (current_target != nil  and self distance_to current_target <= 20){
		 				
//		 				write "moving on the stairs!";
	
		 				// teleport to floor of current_bin
		 				self.location <- {current_target.location.x, current_target.location.y, ((bin_to_clean.floor_no-1)*floor_loc_multiplier)};
		 				self.current_floor_no <- bin_to_clean.floor_no;
		 				// reset stairs target
		 				self.current_target <- nil;
		 			}
	 				
	 				
	 			}
	 			

	 			
	 			// for any other stairs
	 			else if (current_target != nil  and self distance_to current_target > 0.1 and current_target != stairs(1).location) {
	 				
	 				//write "moving to stairs of index WITHIN CLEAN: " + current_target;
	 				//write (self distance_to current_target);
	 				
	 				do goto (target:current_target, on:pedestrian_network_list at (self.current_floor_no-1));
//	 				do goto (target:current_target);
	 				
					total_time_travelled <- total_time_travelled + 1;
	 				
	 			}
	 			
	 			else {
//	 			else if (current_target != nil  and self distance_to current_target <= 0.1 and current_target != stairs(1).location){
	 				
	 				//write "moving on the stairs!";

	 				// teleport to floor of current_bin
	 				self.location <- {location.x, location.y, ((bin_to_clean.floor_no-1)*floor_loc_multiplier)};
	 				self.current_floor_no <- bin_to_clean.floor_no;
	 				// reset stairs target
	 				self.current_target <- nil;
	 			}
	 			
	 			

			
			}
			
			if self.current_floor_no = bin_to_clean.floor_no{
				// once cleaner is on the same floor as the target_bin, go to the bin
	        	do goto (target:bin_to_clean, on:pedestrian_network_list at (self.current_floor_no-1));
	        	total_time_travelled <- total_time_travelled + 1;
        	
        	}
        }
        

        
        // once first bin in the list has been reached
        else if (length(bins_to_clean_order) > 0){
        	// increase trash on hand
			trash_on_hand <- trash_on_hand + bin_to_clean.current_capacity;
        	bin_to_clean.current_capacity <- 0.0;
			bin_to_clean.current_status <- "Empty";
			//write "Finished clearing" + bin_to_clean;
			//remove bin from readyBins so that bin can start filling again while cleaner is cleaning other bins
			remove item: bin_to_clean from:readyBins;
			if BinsAboutToBeFull contains bin_to_clean {
				remove item: bin_to_clean from: BinsAboutToBeFull;
			
			}
//			remove item: bin_to_clean.location from: route;
        	remove item: bin_to_clean from:bins_to_clean_order;
        	bin_to_clean <- nil;
        	
        	if (length(bins_to_clean_order) > 0){
	        	ask bin {
	        		self.current_distance_to_cleaner <- myself.location distance_to self.location;
	        	}
	        	bins_to_clean_order <- bins_to_clean_order sort_by (each.current_distance_to_cleaner);
        	}
        }
        
        //once done with the last bin
        else{
			
			// set bin_to_clean to nil after cleaning cycle
			bin_to_clean <- nil;
			
			
			
			// if central bin is not on the same floor as the cleaner,
			if  self.current_floor_no != 1{
				
				// if the cleaner does not know which stairs to go to
				if current_target = nil{
	 				do find_nearest_available_staircase;
	 			}
	 			
	 			
	 			
	 			// if current_target (stairs) is true:
	 			
	 			if current_target != nil  and self distance_to current_target > 0.1{
	 				
	 				
					//write "walking to my stairs to go home";
					
	 				
	 				
	 				do goto (target:current_target, on:pedestrian_network_list at (self.current_floor_no-1));
					total_time_travelled <- total_time_travelled + 1;
					
	 				//write "after walking, distance btw me and stairs is: " + self distance_to current_target;
					
	 				
	 			}
	 			else if current_target != nil  and self distance_to current_target <= 0.1{
	 				
	 				//write "reached my stairs to go home time to teleport!";
	 				// teleport to floor of central_bin
	 				self.location <- {current_target.location.x, current_target.location.y, 0};
	 				self.current_floor_no <- 1;
	 				// reset stairs target
	 				self.current_target <- nil;
	 				
	 			}

			
			}
			
			else{ // if current floor is 1
			
				if self.central_bin_location = nil{
					do get_central_bin_location;
				}
				
				// once cleaner is on the same floor at the central bin,
	        	if self.location distance_to central_bin_location > 1{
						do goto (target:central_bin_location, on:pedestrian_network_list at (self.current_floor_no-1));
						total_time_travelled <- total_time_travelled + 1;
				}
				
				// to let first reflex function run
				else if location distance_to central_bin_location <= 1{
					//write "Dumping trash into DUMPSTER";
					trash_on_hand <- 0.0;
	        		is_cleaning <- false;
	        		check<- true;
	        		
	        		return_to_rest <- true;
	        	}
	        	else { write "BROKEN";}
        	}
        }
	}       
	
	
    aspect floor_1 {
		if current_floor_no = 1{
			draw circle(6) color: is_cleaning ? #green : #gray depth: 6;
       		draw string("Trash: " + trash_on_hand with_precision 2) color:#black size:(displayTextSize) font:agent_font at:{location.x+(displayTextSize),location.y+(displayTextSize), location.z} perspective:true;
		}
	}
	aspect floor_2 {
		if current_floor_no = 2{
			draw circle(6) color: is_cleaning ? #green : #gray depth: 6;
        	draw string("Trash: " + trash_on_hand with_precision 2) color:#black size:(displayTextSize) font:agent_font at:{location.x+(displayTextSize),location.y+(displayTextSize),location.z} perspective:true;
		}
	}
	aspect floor_3 {
		if current_floor_no = 3{
			draw circle(6) color: is_cleaning ? #green : #gray depth: 6;
        	draw string("Trash: " + trash_on_hand with_precision 2) color:#black size:(displayTextSize) font:agent_font at:{location.x+(displayTextSize),location.y+(displayTextSize),location.z} perspective:true;
		}
	}
	aspect floor_4 {
		if current_floor_no = 4{
			draw circle(6) color: is_cleaning ? #green : #gray depth: 6;
        	draw string("Trash: " + trash_on_hand with_precision 2) color:#black size:(displayTextSize) font:agent_font at:{location.x+(displayTextSize),location.y+(displayTextSize),location.z} perspective:true;
		}
	}
    
}





experiment pedestrian_navigation type: gui {
	parameter "Ready-to-clear Threshold" category:"Waste Bin Thresholds" var: ReadyToClear_multiplier min: 0.0  max: 1.0 step: 0.05 ;
	parameter "About-to-be-full Threshold" category:"Waste Bin Thresholds" var: AboutToBeFull_multiplier min: 0.0  max: 1.0 step: 0.05;
	

    	
    output {
    	
//    	monitor "TOTAL COMPLAINTS" value: total_complaints refresh: every(step);
//    	monitor "ACUMULATED TIME OF BINS OVERFLOWED (MINS): " value: total_time_bin_overflowed/60 refresh: every(step);

		display "Complaints" type: 2d{
			chart "Weekly Complain Numbers" type: series x_label:"Time (minutes)" y_label:"Accumulative Complaints (per Week)"  {
                data "Complaints" value:weekly_complain_log color: #blue marker_size: [0.05] // size keyword instead of size in values
				marker_shape: marker_circle  ;
			}
		}        
       
		display "Overflow" type: 2d{
			chart "Weekly Overflowing Bin Duration" type: series x_label:"Time (minutes)" y_label:"Accumulative Duration (per Week)"  {
                data "Duration" value:weekly_duration_overflow_log color: #darkorange marker_size: [0.05] // size keyword instead of size in values
				marker_shape: marker_circle  ;
			}
		}  



		
		display "Trigger Cleaning" type: 2d{
			chart "Daily Cleaning Cycles Triggered" type: series x_label:"Time (minutes)" y_label:"Accumulative Count of Cleaning Triggered (per Day)"  {
                data "Count" value:daily_cleaner_trigger_count color: #purple marker_size: [0.05] // size keyword instead of size in values
				marker_shape: marker_circle  ;
			}
		} 

        display vidacity_lvl_1 type: opengl background: #lightgrey{
        	
        	// Legend 
             overlay position: { 20, 490 } size: { 1200 #px, 250 #px } background: #black transparency: 0.3 border: #black rounded: true
            {
                float y <- 30#px;
                
                    draw "Legend" at: {20#px, y + 3#px } color: # white font: font("Helvetica", 28, #bold #italic);
                    draw "Failure Metrics" at: {285#px, y + 3#px } color: # white font: font("Helvetica", 28, #bold  #italic);
                    y <- y + 30#px;
					
					// tenant
                    draw triangle(25#px) at: { 30#px, y } color: #magenta ;
                    draw "Tenant" at: { 60#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                	draw ("TOTAL COMPLAINTS: " + total_complaints)  at: { 285#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                    
                    y <- y + 40#px;
                    
                    // Central bin
                    draw square(25#px) at: { 30#px, y } color: #cadetblue;
                    draw "Central Bin" at: { 60#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                	draw ("ACCUMULATED TIME OF BINS OVERFLOWED (MINS): " + (total_time_bin_overflowed/60) with_precision 2)  at: { 285#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                    
                    y <- y + 40#px;
                    
                    // Floor's bin
                    draw square(25#px) at: { 30#px, y } color: #green;
                    draw "Floor's Trash Bin" at: { 60#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                    ask cleaner{                	
                    	draw ("CLEANER DISTANCE TRAVELLED: " + (self.total_time_travelled/3600*self.speed*1000) with_precision 2 + "m")  at: { 285#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                    }
                    
                    y <- y + 40#px;
                    
                    // Cleaner
                    draw circle(12.5#px) at: { 30#px, y } color: #darkgrey;
                    draw "Cleaner" at: { 60#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold);
                    y <- y + 40#px;
                    
                    // Visitor
                    draw sphere(30#px) at: { 30#px, y } color: #snow;
                    draw "Visitors" at: { 60#px, y + 7#px } color: # white font: font("Helvetica", 25, #bold );
                    y <- y + 40#px;
                    

            }
            
            species visitor aspect: default;
            species cleaner aspect: floor_1;
            species cleaner aspect: floor_2;
            species cleaner aspect: floor_3;
            species cleaner aspect: floor_4;

            // floor 1
        	
    		species pedestrian_path aspect:floor_1 transparency: 0.5;
            	
           species bin aspect: floor_1;
            
            species central_bin aspect: default;
            

            species obstacle aspect: floor_1 transparency: 0.80;
            
            species store aspect: floor_1 {
				species people aspect: floor_1;
	
			  }
            
            
            species store_floor aspect: floor_1 transparency: 0.8;
            species vida_lvl_layout_1 transparency: 0.3;
            species stairs aspect: floor_1 transparency: 0.9;
            
            
            
            // floor 2
            
            species pedestrian_path aspect:floor_2 transparency: 0.5;
            	
            species bin aspect: floor_2;
           
            

            species obstacle aspect: floor_2 transparency: 0.80;
            
            species store aspect: floor_2 {
				species people aspect: floor_2;
	
			  }
            
           
            
            species store_floor aspect: floor_2 transparency: 0.8;
            species vida_lvl_layout_2 transparency: 0.3;
            species stairs aspect: floor_2 transparency: 0.9;
            
            
            //floor 3
            
            species pedestrian_path aspect:floor_3 transparency: 0.5;
            	
            species bin aspect: floor_3;
           
            

            species obstacle aspect: floor_3 transparency: 0.80;
            
            species store aspect: floor_3 {
				species people aspect: floor_3;
	
			  }
            
            
            species store_floor aspect: floor_3 transparency: 0.8;
            species vida_lvl_layout_3 transparency: 0.3;
            species stairs aspect: floor_3 transparency: 0.9;
            
            
            //floor 4
            
            species pedestrian_path aspect:floor_4 transparency: 0.5;
            	
            species bin aspect: floor_4;
           
            

            species obstacle aspect: floor_4 transparency: 0.80;
            
            species store aspect: floor_4 {
				species people aspect: floor_4;
	
			}
            
            
            
            species store_floor aspect: floor_4 transparency: 0.8;
            species vida_lvl_layout_4 transparency: 0.3;
            species stairs aspect: floor_4 transparency: 0.9;
            
            
            
            
            
       }
         


	}
}



